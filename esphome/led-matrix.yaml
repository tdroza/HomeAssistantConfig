esphome:
  name: $device_name
  on_boot:
    switch.turn_on: matrix_enabled
    
substitutions:
  device_name: led-matrix
  friendly_name: LED Matrix
esp8266:
  board: d1_mini

# Enable logging
logger:

# Enable Home Assistant API
api:
  services:
    - service: show_time
      then:
        - display.page.show: page_time
        - component.update: led_matrix_display
    - service: show_image
      variables:
        id: int
      then:
        - lambda: id(image_id) = id;
        - display.page.show: page_image
        - component.update: led_matrix_display
    - service: rectangle
      variables:
        x: int
        y: int
        w: int
        h: int
      then:
        - lambda: |-
            id(start_x) = x;
            id(start_y) = y;
            id(rect_w) = w;
            id(rect_h) = h;
        - display.page.show: page_rect
        - component.update: led_matrix_display
    - service: print_text
      variables:
        text: string
        x: int
        y: int
      then:
        - lambda: |-
            id(display_text) = text;
            id(start_x) = x;
            id(start_y) = y;
        - logger.log:
            format: "Received %s"
            args: [ 'id(display_text).c_str()' ]
        - display.page.show: text_page
        - component.update: led_matrix_display
        
    - service: scroll_text
      variables:
        text: string
      then:
        - lambda: id(display_text) = text;
        - logger.log:
            format: "Received %s"
            args: [ 'id(display_text).c_str()' ]
        - display.page.show: scroll_text_page
        - component.update: led_matrix_display
    - service: show_pattern
      then:
        - display.page.show: pattern_page
        - component.update: led_matrix_display
          
globals: 
  - id: image_id
    restore_value: no
    initial_value: "1"
    type: int
  - id: display_text
    restore_value: no
    initial_value: ""
    type: std::string
  - id: start_x
    restore_value: no
    initial_value: "0"
    type: int
  - id: start_y
    restore_value: no
    initial_value: "0"
    type: int
  - id: rect_w
    restore_value: no
    initial_value: "16"
    type: int
  - id: rect_h
    restore_value: no
    initial_value: "8"
    type: int

ota:

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Led-Matrix Fallback Hotspot"
    password: !secret wifi_password

captive_portal:

switch:
  - platform: template
    optimistic: true
    name: "${friendly_name} Enabled"
    id: matrix_enabled
    on_turn_on:
      - logger.log: "Matrix Enabled"
      - lambda: id(led_matrix_display).set_enabled(true);
    on_turn_off: 
      - logger.log: "Matrix Disabled"
      - lambda: id(led_matrix_display).set_enabled(false);

light:
  - platform: fastled_clockless
    chipset: WS2812
    pin: D4
    num_leds: 128
    rgb_order: GRB
    name: "led_matrix"
    id: led_matrix_light
    default_transition_length: 0s
    color_correct: [25%, 25%, 25%]
    restore_mode: ALWAYS_ON
    effects:
      - addressable_color_wipe:
      - addressable_rainbow:
      - addressable_random_twinkle:
      - addressable_fireworks:
          use_random_color: true
      - addressable_lambda:
          name: "Fire"
          update_interval: 16ms
          lambda: |-
            // You may adjust the following two variables as well as the update_interval to fit your needs
            const uint8_t Cooling  = 55;
            const uint8_t Sparking = 110;
            const uint8_t width = 16;
            const uint8_t height = 8;
            
            // Use byte* instead of byte[] to allow dynamic allocation based on number of pixels
            static byte *heat = (byte*) calloc(height, sizeof(byte));
            int cooldown;
            
            for (uint8_t x = 0; x < width; x++) {
              // Step 1.  Cool down every cell a little
              for (uint8_t i = 0; i < height; i++) {
                cooldown = random(0, ((Cooling * 10) / height) + 2);
                if (cooldown > heat[i]) {
                  heat[i] = 0;
                } else {
                  heat[i] = heat[i] - cooldown;
                }
              }
              // Step 2.  Heat from each cell drifts 'up' and diffuses a little
              for (uint16_t k = height - 1; k >= 2; k--) {
                heat[k] = (heat[k - 1] + heat[k - 2] + heat[k - 2]) / 3;
              }
              // Step 3.  Randomly ignite new 'sparks' near the bottom
              if (random(255) < Sparking) {
                int y = random(min(height / 10, 7));
                heat[y] = heat[y] + random(160, 255);
              }
              // Step 4.  Convert heat to LED colors
              for (uint16_t y = 0; y < height; y++) {
                uint16_t Pixel;
                if (y%2==0) {
                  Pixel=y*width+x;
                } else {
                  Pixel = ((y+1)*16) - (x+1);
                }
                // Scale 'heat' down from 0-255 to 0-191
                byte t192 = round((heat[Pixel] / 255.0) * 191);
                // calculate ramp up from
                byte heatramp = t192 & 0x3F; // 0..63
                heatramp <<= 2; // scale up to 0..252
                // figure out which third of the spectrum we're in:
                //this is where you can reverse the effect by switching the commented out lines in all 3 places.
                if (t192 > 0x80) {                     // hottest
                  //it[it.size() - Pixel - 1] = ESPColor(255, 255, heatramp);
                  it[Pixel] = ESPColor(255, 255, heatramp);
                } else if (t192 > 0x40 ) {             // middle
                  //it[it.size() - Pixel - 1] = ESPColor(255, heatramp, 0);
                  it[Pixel] = ESPColor(255, heatramp, 0);
                } else {                               // coolest
                  //it[it.size() - Pixel - 1] = ESPColor(heatramp, 0, 0);
                  it[Pixel] = ESPColor(heatramp, 0, 0);
                }
              }
            }
font:
  - id: tinier_font
    file: "fonts/5by7.ttf"
    size: 10
    glyphs: '♡''&Ωäöüß£!"%()+,-_.:*=°?~#0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz'
  - id: tiny_font
    file: "fonts/DejaVuSans-Bold.ttf"
    size: 9
    glyphs: '♡''&Ωäöüß£!"%()+,-_.:*=°?~#0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz'
    
image:
  - file: "images/cool.png"
    id: cool
    resize: 16x16
    type: RGB24
  - file: "images/tom32x32.jpg"
    id: tom
    resize: 16x16
    type: RGB24

time:
  - platform: homeassistant
    id: esptime
    
display:
  - platform: addressable_light
    id: led_matrix_display
    addressable_light_id: led_matrix_light
    width: 16
    height: 8
    rotation: 0°
    update_interval: 100ms
    pixel_mapper: |-
      if ((y%2) == 0)  {
        return (y*16) + x;
      } else {
        return ((y+1)*16) - (x+1);
      }

    pages:
      - id: page_image
        lambda: |-
          static uint16_t ypos = 0;
          static int8_t direction = -1;
          if (id(image_id) == 1) {
            it.image(0, -ypos, id(cool));
          } else if (id(image_id) == 2) {
            it.image(0, -ypos, id(tom));
          }
          if ((ypos % id(cool).get_height()) == 0) {
            direction *= -1;
          }
          if (direction > 0) {
            ypos++;
          } else {
            ypos--;
          }

      - id: page_time
        lambda: |-
          static int8_t xpos = 0;
          static int8_t direction = -1;
          
          Color green = Color(0x00FF00);

          int x_start, y_start;
          int width, height;
          
          char text[5];
          id(esptime).now().strftime(text, 6, "%H:%M");    
          it.get_text_bounds(0, 0, text, id(tinier_font), TextAlign::CENTER_LEFT, &x_start, &y_start, &width, &height);
          
          it.print(xpos%width,4,id(tinier_font), green, TextAlign::CENTER_LEFT, text);

          if ((direction <= 0 && xpos <= it.get_width() - width) || 
            (direction > 0 && xpos >= 0)) {
            direction *= -1;
          }
          if (direction > 0) {
            xpos++;
          } else {
            xpos--;
          }
      - id: page_rect
        lambda: |-
          Color blue = Color(0x0000FF);
          it.rectangle(id(start_x), id(start_y), id(rect_w), id(rect_h) , blue);
      - id: pattern_page
        lambda: |-
          Color red = Color(0xFF0000);
          Color green = Color(0x00FF00);
          it.filled_rectangle(0, 0, 16, 8, red);
          it.rectangle(1, 1, 14, 6, green);
          it.rectangle(3, 3, 12, 2, green);
      - id: text_page
        lambda: |-
          Color green = Color(0x00FF00);
          const char * text = id(display_text).c_str();
     
          int x_start, y_start;
          it.print(id(start_x), id(start_y), id(tinier_font), green, TextAlign::TOP_LEFT, text); 
      - id: scroll_text_page
        lambda: |-
          #define xscrollpadding 4
          Color red = Color(0xFF0000);
          Color green = Color(0x00FF00);
          static uint16_t xpos = 0;
          const char * text = id(display_text).c_str();
     
          int x_start, y_start;
          int width, height;
              
          it.get_text_bounds(0, 0, text, id(tiny_font), TextAlign::TOP_LEFT, &x_start, &y_start, &width, &height); 
          it.print(-(xpos % (width + xscrollpadding)), -2, id(tiny_font), red, TextAlign::TOP_LEFT, text); 
          xpos++;
          